defmodule Permit.Phoenix.Actions do
  @moduledoc """
  Defines action names for your permissions schema, so that convenience functions
  are generated for them.

  ## Recommended usage

  ```
  defmodule MyApp.Actions do
    # Merge the actions from the router into the default grouping schema
    use Permit.Phoenix.Actions, router: MyApp.Router

    # Additional singular actions throughout the app
    def singular_actions, do: [:view]
  end
  ```

  ## Overview

  Default action grouping for Phoenix includes:
  - `:create`, implying permission to `:new` and `:create` actions
  - `:read`, implying permission to `:index` and `:show` actions
  - `:update`, implying permission to `:edit` and `:update` actions
  - `:delete`, implying permission to `:delete` action

  By granting a permission to `:read`, you also allow `:index` and `:show`. You can
  also grant permissions to individual actions specifically - if you only grant
  `:index`, `:show` will not be authorized.

  This is coded as:
  ```
  %{
    create: [],
    read: [],
    update: [],
    delete: [],
    new: [:create],
    index: [:read],
    show: [:read],
    edit: [:update]
  }
  ```

  If you want to declare an action that requires more than one permission, you can
  define a grouping:
  ```
  %{
    access: [],
    view: [],
    open: [:accsess, :view] # if both are granted, :open will be authorized
  }
  ```

  ## Singular vs plural actions

  Singular actions are those that operate on a single resource, such as `:show` or `:update`.
  Plural actions operate on a collection of resources, such as `:index`. Depending on the arity,
  queries generated by Permit.Ecto will be executed as `LIMIT 1` (for singular actions) or with
  any limit given in the `base_query` (for plural actions).

  Each action in Permit is assumed to be plural by default. To declare an action as singular,
  you can implement the `singular_actions/0` callback. This can be implemented in your actions module
  and overridden in your controller or LiveView module.

  Default singular actions are `:show`, `:edit`, `:new`, `:delete`, `:update` **and** those
  inferred from the router - see section below. The `singular_actions/0` callback can be used to add more
  - it does not require calling `super`.

  ## Example

      defmodule MyApp.Actions do
        use Permit.Phoenix.Actions

        # In addition to the default singular actions. If `:view` always deals with a single record
        # throughout the app, it can be declared as singular in this module.

        @impl true
        def singular_actions, do: [:view]
      end

  Actions can also be configured as singular or plural in the controller or LiveView module
  itself, which takes precedence over the actions module.

  If a controller or LiveView contains a `:view` action that deals with an index of records,
  it can be overridden as plural in the controller or LiveView module. `super()` will contain
  the actions module's configuration.

  ```
  defmodule MyApp.ArticleController do
    use Permit.Phoenix.Controller

    @impl true
    def singular_actions, do: super() -- [:view]
  end
  ```

  ## Router

  It is recommended to read action names from the router, so that all controller
  action and `:live_action` names are automatically included and convenience functions
  for them are generated. Moreover, actions are automatically inferred to be singular or plural based on the route definition.
  An action is singular by default if:
  - it's one of: `:show`, `:edit`, `:new`, `:delete`, `:update`, `:create`, or
  - it is a POST request, or
  - it's a route with an `:id`, `:uuid` or `:slug` parameter, e.g. `/items/:id/view` or `/items/:uuid/view`, or
  - the route's last segment is a parameter, e.g. `/items/:name`, `/items/:identifier`.

  ```
  defmodule MyApp.Router do
    # ...

    get("/items/:id", MyApp.ItemController, :view)
  end

  defmodule MyApp.Actions do
    # Merge the actions from the router into the default grouping schema.
    use Permit.Phoenix.Actions, router: MyApp.Router

    # This doesn't need to be used - Permit automatically infers that the :view action is
    # singular.
    # You can use it if an explicit declaration is needed, e.g. if you use a different ID
    # parameter than `:id`, `:uuid` or `:slug`.
    @impl true
    def singular_actions, do: [:view]
  end

  defmodule MyApp.Permissions do
    # Use the actions module to define permissions.
    use Permit.Permissions, actions_module: MyApp.Actions

    def can(%User{role: :admin} = _user) do
      permit()
      |> all(Item)
    end

    # The `view` action is automatically added to the grouping schema
    # and hence available as a `view/2`function when defining permissions.
    def can(%User{role: :owner} = _user) do
      permit()
      |> view(Item)
      |> all(Item, fn user, item -> item.owner_id == user.id end)
    end
  end
  ```
  """

  use Permit.Actions

  @default_singular_actions [:show, :edit, :new, :delete, :update, :create]

  defmacro __using__(opts) do
    singular_actions_from_router =
      __MODULE__.singular_actions(Macro.expand(opts[:router], __ENV__))

    quote do
      use Permit.Actions

      def grouping_schema do
        unquote(__MODULE__).grouping_schema()
        |> unquote(__MODULE__).merge_from_router(unquote(opts)[:router])
      end

      def singular_actions do
        unquote(singular_actions_from_router)
      end

      defoverridable grouping_schema: 0, singular_actions: 0
    end
  end

  @doc """
  Returns the default action grouping schema for Phoenix applications.
  """
  @impl Permit.Actions
  def grouping_schema do
    %{
      new: [:create],
      index: [:read],
      show: [:read],
      edit: [:update]
    }
    |> Map.merge(crud_grouping())
  end

  @doc """
  Returns the list of actions that operate on a single resource.
  """
  def singular_actions(router_module)

  def singular_actions(nil), do: @default_singular_actions

  def singular_actions(router_module) do
    router_module
    |> filtered_routes_stream()
    |> Stream.filter(fn %{path: path, verb: verb} = _route ->
      # Plug.Router.Utils is private API, subject to change. Hasn't changed in years, though.
      {param_name_atoms, segments} = Plug.Router.Utils.build_path_match(path)

      last_segment = List.last(segments)

      # Last path part is a param, e.g. `/articles/:id` or `/articles/:name`
      last_segment_is_param =
        case last_segment do
          {_param_name_atom, _, _} -> true
          _ -> false
        end

      # Any param clearly looks like an ID, e.g. `:id`, `:uuid` or `:slug`
      any_param_is_id_like =
        Enum.any?(param_name_atoms, &(&1 in [:id, :uuid, :slug]))

      # Post routes are always singular, while PUT, etc. can be either singular or plural.
      verb == :post or last_segment_is_param or any_param_is_id_like
    end)
    |> Stream.map(fn route -> route.plug_opts end)
    |> Stream.concat(@default_singular_actions)
    |> Enum.uniq()
  end

  def merge_from_router(grouping_schema, nil), do: grouping_schema

  def merge_from_router(grouping_schema, router_module) do
    action_names_from_router(router_module)
    |> Enum.reduce(grouping_schema, fn action, acc ->
      if Map.has_key?(acc, action), do: acc, else: Map.put(acc, action, [])
    end)
  end

  def filtered_routes_stream(router_module) do
    router_module.__routes__()
    |> Stream.filter(&controller_or_live_route?/1)
  end

  def action_names_from_router(router_module) do
    filtered_routes_stream(router_module)
    |> Stream.map(fn route -> route.plug_opts end)
    |> Enum.uniq()
  end

  def paths_from_router(router_module) do
    filtered_routes_stream(router_module)
    |> Stream.map(fn route -> route.path end)
    |> Enum.uniq()
  end

  defp controller_or_live_route?(route) do
    controller_route?(route) or live_route?(route)
  end

  defp live_route?(route) do
    !!get_in(route, [:metadata, :phoenix_live_view])
  end

  defp controller_route?(route) do
    is_atom(route.plug_opts) and is_atom(route.plug) and Code.ensure_loaded?(route.plug) and
      function_exported?(route.plug, route.plug_opts, 2)
  end
end
